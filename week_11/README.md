# Упражнение #11

## Какво научихме предния път?
* Указатели, употреба, референции

## Какво ще научим днес?
* Указатели и масиви
* Динамична памет introduction

<br>

## Константи НАЙ-ВАЖНО:
<br>

**Обобщено: При константен указател към константа, адресът и стойността на клетката не могат да бъдат променяни.**
#### Трябва само да запомните 4 правила и те са доста логични:

* Неконстантен указател, може да бъде пренасовчан към други адреси
* Константният указател, сочи към един и същ адрес, и този адрес не може да бъде променян
* На указател към неконстантна стойност може да се променя стойността, която той сочи. Те не могат да сочат към константа.
* Указател към константна стойност се отнася към стойността като към константа(дори и да не е), и по този начин не може да се промени стойността, която те сочат.

```c++
int value = 5;
const int *ptr1 = &value; // ptr1 сочи към "const int", това е указател към константа
int *const ptr2 = &value; // ptr2 сочи към "int", това е константен указател, към неконстантна стойност(променлива)
const int *const ptr3 = &value; // ptr3 сочи към "const int", това е константен указател към константа
```
<br>

## Референции (останало от предния път):
<br>


### Връзка с указателите
<br>

Референциите и указателите имат интересна връзка - референцията действа като указател, който се използва за достъп до променливата.
```c++
int value = 5;
int *const ptr = &value;
int &ref = value;
```
* ptr и ref се оценяват по един и същ начин. В резултат на това, следните две твърдения са еквивалентни:
```c++
*ptr = 5;
ref = 5;
```
Референциите, обикновено, са много по-безопасни от указателите. Въпреки това, те също са малко по-ограничени в функционалност съответно.
Ако дадена задача може да бъде решена с референция или с указател, по принцип трябва да се предпочита референцията. Указателите трябва да се използват само в ситуации, при които референциите не са достатъчни (като динамично заделяне на памет).

### Const

#### Референция към константа(или още константен псевдоним(Не се бъркайте с указатели, там са 2 различни неща!))
Точно както е възможно да се декларира иказател към константна стойност, също е възможно да се декларира референция към константна стойност. Това се прави чрез деклариране на псевдоним с помощта на ключовата дума const.
```c++
const int value = 5; // константа от тип int
const int &ref = value; // ref е псевдоним на константата value
```
#### Инициализация
```c++
int x = 5;
const int &ref1 = x; // okay, x е променлива
 
const int y = 7;
const int &ref2 = y; // okay, y е константа
```
Подобно на указател към константа, **референция към константа може да реферира неконстантна стойност(променлива).** При достъп, чрез референцията, стойността се счита за константна, дори ако оригиналната стойност не е, следователно не можем да я променим.
```c++
int value = 5; // Обикновена променлива
const int &ref = value; // псевдоним към константна стойност на value
 
value = 6; // okay, value не е константа
ref = 7; // not okay, ref е "константен псевдоним"
```
**Обобщено: При референция към константна стойност, стойността(константна или не), достъпвана чрез псевдонима, не може да се променя. Може да се променя самата променлива.

<br>

## Указатели и масиви
<br>

Споменахме ли, че масивът е "указател"? Трудно е да повявате? Създайте масив (да кажем от double), след това напишете:
```c++
double arr[5] = { 4, 5, 6, 7.6, 9 };
std::cout << arr << std::endl; // Ще се изпише на конзолата: 0x7ffcd4326470 
int *ptr = arr;
std::cout << ptr << std::endl; // Ще се изпише на конзолата: 0x7ffcd4326470
```
Това е така, защото **когато създаваме масив ние всъщност създаваме указател към първия елемент на масива** и когато казваме arr[index] (еквивалентно на \*(arr + index)) казваме дай ми елементът, който се намира на позицията на: адреса на първия елемент + отместване. На пръв поглед изглежда, че мавив и указател са едно и също. Но те не са. Основната разлика се илюстрира при използване на оператора sizeof(). Когато се използва върху масив, sizeof връща размера на целия масив (дължина на масива * размера на типа на елемента). Когато се използва върху указател сочещ масив, sizeof връща размера на адресa в паметта(в байтове). Следната програма илюстрира това:
```c++
#include <iostream>
using namespace std; 
int main()
{
	int array[5] = {1, 2, 3, 4, 5};
 
	cout << sizeof(array) << endl; // ще принтира sizeof(int) * дължината на масива
 
    int *ptr = array;
    cout << sizeof(ptr) << endl; // ще принтира размера на указателя
 
	return 0;
}
```
Изход:

	20
	4

**Масивът(разглеждан като указател към първия елемент) сам за себе си знае колко е дълъг(нали използваме [], за да му го кажем). Указател, сочещ масива не го знае, знае само къде започва.**
Е, вече имаме едно доказателство, което не потвърждава равенството. Следователно отхвърляме твърдението, че масив и указател са едно и също нещо.
#### Адресна аритметика
Езикът C++ ни позволява да извършваме операции за добавяне или изваждане на адреси от указателя. Ако ptr сочи към цялото число, ptr + 1 е адреса на следващото цяло число в паметта след ptr. А ptr - 1 е адресът на предишното цяло число преди ptr. Имайте предвид, че ptr + 1 не връща адреса на паметта след ptr, а адреса на паметта на следващия обект от типа, към който сочи ptr. Ако ptr сочи към цяло число (4 байта), ptr + 3 означава 3 цели числа (12 байта) след ptr. Ако ptr сочи знак, който винаги е 1 байт, ptr + 3 означава 3 символа (3 байта) след ptr.
```c++
#include <iostream>
 
int main()
{
    int value = 7;
    int *ptr = &value;
 
    std::cout << ptr << '\n';
    std::cout << ptr+1 << '\n';
    std::cout << ptr+2 << '\n';
    std::cout << ptr+3 << '\n';
 
    return 0;
}
```
Изход:

	0x7df9abb0acbc
	0x7df9abb0acc0
	0x7df9abb0acc4
	0x7df9abb0acc8

Може също директно да извадите 2 адреса(например началото и края на масив), като така получавате броя клетки от първия(вкл.) до втория адрес.
```c++
int main()
{
    int values[5] = {11, 38, 99, 4, 7};
    int *ptr = values;
    int *ptr2 = values + 4;
 
    std::cout << ptr2 - ptr << '\n';
     
    return 0;
}
```
Изход:

	4
Как можем да използваме това? Както споменахме в преди. Масивът е **поредица от еднотипни променливи(елементи)**, които се съхраняват **последователно** в паметта. След това видяхме, че **името на масива е указател към първият му елемент**. Сега видяхме, че с указателите могат да се извършват **операции по добавяне и изваждане** на брой клетки от дадена клетка. Сега ще използваме всичко това за да итерираме в масива, не чрез индекси, а чрез указатели.
```c++
#include <iostream>
using namespace std; 
int main()
{
     int array [5] = {9, 4, 5, 3, 8};
 
     cout << &array[1] << '\n'; // ще изведе адреса в паметта на втория елемент на масива
     cout << array+1 << '\n'; // ще изведе адреса в паметта на втория елемент на масива 
 
     cout << array[1] << '\n'; // ще изведе 4
     cout << *(array+1) << '\n'; // ще изведе 4 () са задължителни
 
    return 0;
}
```
Следователно **array[1] и \*(array + 1) ** са напълно еквиваленти.

##### Подаване на масив като параметър на функция(разширение)
#### Синтаксис за едномерен масив

	return_type/void <function_name>( <type> <name>[], <integer_type> <size>);
	return_type/void <function_name>( <type> *<name>, <integer_type> <size>);

Пример:
```c++
int sumAllElementsInArray(int arr[], int size);
int sumAllElementsInArray(int *arr, int size);
```
Извикването става, само с името на масива:
```c++
// somewhere in main()

	int my_arr[5] = {1, 2, 3, 4, 5};
	...
	cout << sumAllElementsInArray(my_arr, 5);
```
#### Синтаксис за двумерен масив

	return_type/void <function_name>( <type> <name>[][<maximum_size_of_columns>], <integer_type> <size_of_rows>, <integer_type> <size_of_rows>);
	return_type/void <function_name>( <type> *(<name>)[<maximum_size_of_columns>], <integer_type> <size_of_rows>, <integer_type> <size_of_rows>);

Пример:
```c++
int sumAllElementsInMatrix(int mrx[][10], int rowSize, int columnSize);
int sumAllElementsInMatrix(int *(mrx)[10], int rowSize, int columnSize);
```
Извикването става, само с името на масива:
```c++
// somewhere in main()

	int my_mrx[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
	...
	cout << sumAllElementsInMatrix(my_mrx, 3, 3);
```

### NB! Не можем да връщаме масив от функция. Но можем да върнем указател. Виж следващата точка.

### Функции(advanced level)
#### Параметри vs. Аргументи
**Параметър** на функция (понякога наричан **формален параметър**) е променлива, използвана при декларацията/дефиницията на функцията.
```c++
void foo(int x); // декларация (прототип на функцията) -x е параметър
 
void foo(int x) // дефиниция  -x е параметър
{
}
```
**Аргумент** (понякога наричан **действителен параметър**) е стойността, която се подава на функцията при извикването й.
```c++
foo(6); // 6 е аргумент предаден на параметъра x
```
Когато някъде се извика функцията foo() се с аргумента 6, параметърът х на foo се създава и инициализира със стойността на аргумента(т.е. със 6). Параметрите имат локална видимост и затова, когато функцията завърши изпълнението си те се разрушават.
```c++
void foo(int x) // х се създава тук
{
} // х се унищожава тук
```

#### Подаване на аргументи към финкции по стойност, адрес и референция
Когато използваме функции(както го правим до сега) и подаваме даден аргумент (подаване по стойност), ние дефакто създаваме нова променлива някъде в паметта (виж графиката) и всички промени които осъществим се правят над новата променлива, но не и над променливата която сме подали.

За да правим промени над оригиналните променливи, които сме подали, се използват указателите и псевдонимите. 

Казано разговорно какво представляват:
	- Псевдонимът казва, когато подадеш дадена променлива, на тази която се присвоява, направо я взима по референция, т.е направо я вземи където се намира по адреса, който е и оперира в оригиналната памет.
	- Указател - подаваме адреса на променливата и оперираме над него


![](images/PRF.png) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


Пример: Искаме да намерим сумата на две числа, като използваме трета променлива в която да се пази резултата. (т.е за учебна цел няма да връщам сумата като резултат, а ще пазя резултата в предварително създадена променлива)

```c++
// Example program
#include <iostream>

// without reference or pointer => will lose value of sum
void sumWithoutRefOrPointer(int numL, int numR, int sum)
{
    sum = numL + numR;
}

// with reference
void sumIt(int numL, int numR, int &sum)
{
    sum = numL + numR;
}

// with pointer
void sumIt(int numL, int numR, int *sum)
{
    *sum = numL + numR;
}

int main()
{
  int numL = 4, numR = 6, sum = 0;
  
  sumWithoutRefOrPointer(numL, numR, sum);
  std::cout << "1) " << sum << std::endl; // 0
  
  sumIt(numL, numR, sum);
  std::cout << "2) " << sum << std::endl; // 10
  
  sumIt(numL + 1, numR, &sum); // we must put adress of sum
  std::cout << "3) " << sum << std::endl; // 11

  return 0;

}
```

Виждаме това което коментираме до сега. Там къде сме подали по стойност (т.е. първата функция), правим копие и след края на изпълнение се трие това копие, като стойността на sum (това е main) не е променена.
Когато подаваме по референция ние работим директно в паметта и от там идва и промяната на стойността на променливата sum.
При използването на указател наблюдаваме същото, вземи адреса на променливата и след това с * казваме влез вътре и промени стойността.